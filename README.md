# Аннотация к проекту

Проект создавался для решения одной единсвенной проблемы. Как быстро и удобно собраться группе
людей с самыми разными личными графиками?

Суть в том, что люди вносят свой график создают группы и графики участников сравниваются 
и все пользователи видят промежутки времени когда они все одновременно свободны. Не нужно вызванивать, дергать друг друга, назначать организатора.
Теперь достаточно просто внести свой график добавить друга и посмотреть когда можете пойти потусить вместе))))

Также удобно и в коммерчеком направлении использовать. Условно есть компания с 20 сотрудниками. 
Они создают группу и компании будет удобнее подобрать  оптимальное время для своего персонала.

Большинство персональных планировщик проигрывают нам, потому что они персональные)) Суть в том, что там
куча сверх удобного редактирования своих ивентов, но дальше профита в 15 минут от этого редактирования выйграть в большинстве случаем.
А выяснить когда кучу разных непонятных типов можно собрать посложнее задачка)))

Если раскатывать губу, то можно вкинуть еще карту и рекомендовать всякие места, где бабки на досуг можно потратить, условно боулинг или жральня
повышая удобство своего продукта для пользователя и хватая бабки за рекламу с этих самых боулингов))))))

Проект MeetUp состоит из 3 частей:

1. Клиент на QT.

2. Асинхронный http сервер.

3. База данных на PostgreSQL.

# Реализация сервера
Принимает POST/ с JSON в теле запроса.

JSON типа {“type_request” : {“.” : “....”, ....}}

Примеры в файле TEST.

Request: add_event: {"add_event":[{"user_id":"56","event_name":"breakfast","event_date":"01-06-2000", "description":"2132", "time_begin":"15:45", "time_end":"16:00"}]}

Response: {"add_event":{"event_id":"56"}}

Далее передается в карту обработки. Если такой запрос существует передает соответствующему парсеру
для конвертации в нужную структуру. Будь то ивент, персональные данные, или данные по группам, контактам.
Далее данные передаются для обработки. (Занесение в базу, поиск в базе)
Затем конвертируются обратно в строку и высылаются клиенту.


### Порядок работы:
1. Сервер получает запрос. 
2. Чекает его.
3. Достает тело запроса.
4. Передает в Route.
5. Route вычлеяет тип запроса и смотрит есть ли в карте такой обработчик.
6. Находит нужное звено по карте (project/route/src/RouteImpl.hpp строка 103-105)
7. Передает в соответствующий парсер (лежат в project/parser_class/JSON/*) этого звена, формирует нужную структуру, будь то группа или контакты и т.д..

Поля несущих структур можно посмотреть в project/parser_object/include/Structs.hpp

8. Записывает эти стурктуры в большой объект (ParserObject, лежит в project/parser_object/include/ParserObject.hpp), который умеет впитывать их в себя, его задача исключительно переносная между парсерами и обработчиками.
9. Передает этот крупный объект в обработчик а обработчик уже знает нужные ему поля, чаще всего строку в стуктуре вложенную в этот ParserObject.
10. Метод обработчик уже юзает методы коннекторы к базе(Select, Update, Delete, Select + Join), чтобы создать ивент или удалить группу и так далее.
   
Методы коннекторы прописаны в project/database_connector/PorstgreSQL/*

11. Отдает успех, неуспех, в случае последнего где и что вызвало проблемы. В некоторых ответах отдает ID
новой сущности или каскаду всех однотипных сущностей закрепленных за 1 пользователем.
12. Вписывает ответ в ParserObject.
13. ParserObject в парсер.
14. Строку из парсера клиенту.

Карту запросов можно глянуть в project/route/include/impl/RouteMapKeys.hpp
Все звенья обработки можно глянуть в project/route/src/RouteImpl.hpp

Карту БД можно воссоздать из файла project/database_connector/SQL/pool.sql

### Каркас сервера:

Асинхронный механизм (1 реальный, куча виртуальных потоков). 
Созданы асинхронные аналоги чтения и записи из файла, асинхронный потоки на их основе,
цикл событий контролирующий работу сервера. Также модули реализующие слушающий сокет и client acceptor.

### Косяки:

Некорректное тело запроса валит сервер на парсинге (не успели обработать).

Не использовали механизм исключений т.к. мало известная область. Руководстовались принципом, 
что если проблему можно отловить if'ом, то надо его юзать, а не
особый и вместе с тем медленный механизм исключений.

Стилистика не выдерживает единного стиля, работаем над этим.

### Важно:

Переписать костяк сервера на boost'e. 

# Сборка
```bash
make build
```

#Запуск
```bash
make launch
```

#Необходиые библиотеки
```bash
1. nlohmann/json (есть в проекте).
2. libpq (ключ для компилятора -lpq) нужно предварительно установить в системе.
Команда: sudo pacman -S postgresql (для оболочки Manjaro).
```
